<!DOCTYPE html>
<html>
  <head>
    <title>Composer</title>
    <style>
      body { margin:0px; padding:0px; background: #000;}
      @font-face {
        font-family: "ProggyClean";
        src: url('fonts/ProggyClean.ttf');
      }
    </style>
    <script type="text/javascript" src="/carena.js"></script>
    <script type="text/javascript" src="/lib/composer.js"></script>
    <script type="text/javascript" src="/cider.js"></script>
    <script type="text/javascript" src="/lib/chisel.js"></script>

    <script src="lib/jquery.js"></script>
    <script type="text/javascript">
      jQuery(function() {
        var feature  = carena.feature,
            renderer = carena.build({}, ["carena.Renderer"], {
              canvas: document.getElementById("composer"),
              style: {
                backgroundColor : "rgb(0,0,0)"
              }
            }),
            camera = carena.build({},
              [
                "carena.Eventable",
                "carena.Camera",
                "carena.DragManager",
                "carena.DropManager",
                "composer.ModalManager"
              ], {
              renderer: renderer
            }),
            scene;

        composer.chisel.modalManager = camera;

        var fromTransport = function(obj) {

          var flow = carena.build({
            x     : 0,
            y     : 0,
            width : 100,
            height: 100,
            color : 'darkgrey'},
          [
            "carena.Node",
            "carena.Eventable",
            "carena.Draggable",
            "carena.RelativeToParent",
          ]);

          // Recreate the nodes
          if (obj.nodes) {
            var nodeCount = 0, idMap = {};
            for (var nodeId in obj.nodes) {
              if (obj.nodes.hasOwnProperty(nodeId)) {
                nodeCount++;
                composer.createNode(nodeId, obj.nodes[nodeId], function(err, node) {
                  nodeCount--;
                  if (err) {
                    console.log(err);
                    return;
                  }
                  // TODO: keep the id map in carena
                  idMap[node.myId] = node;
                  flow.add(node);

                  if (nodeCount <= 0 && obj.pipes) {
                    for (var pipeIdx in obj.pipes) {
                      if (obj.pipes.hasOwnProperty(pipeIdx)) {
                       var pipeObj = carena.build({},['composer.Pipe']);
                       var pipe = obj.pipes[pipeIdx];
                       var sourcePorts = idMap[pipe.source.id].ports;
                       var targetPorts = idMap[pipe.target.id].ports;
                       var port;

                       for (var i=0; i<sourcePorts.length; i++) {
                        port = sourcePorts[i];

                        if (port.direction === pipe.source.port[0] &&
                            port.name === pipe.source.port[1])
                        {
                          pipeObj.source = port;
                          break;
                        }
                       }

                       for (var i=0; i<targetPorts.length; i++) {
                        port = targetPorts[i];
                        if (port.direction === pipe.target.port[0] &&
                            port.name === pipe.target.port[1])
                        {
                          pipeObj.target = port;
                          // parent the pipe so it will get rendered
                          var source = pipeObj.source, target = pipeObj.target;
                          var commonParent = carena.commonAncestor(source,
                                                                   target);
                          if (commonParent) {
                            commonParent.unshift(pipeObj);
                          }
                          break;
                        }
                       }
                      }
                    }
                  }
                });
              }
            }
          }
          return flow;
        };

        var toTransport = window.toTransport = function(branch) {
          var res = {
            type : "flow",
            name : composer.currentFlow,
          },
          nodes = {},
          pipes = [],
          recurse = function(node) {
            if (node.hasFeature("composer.Functional") && node.parent === branch) {
              nodes[node.myId] = {
                type    : node.type,
                name    : node.name || node.myId,
                options : {
                  x : node.x,
                  y : node.y,
                  style : {
                    backgroundColor : node.style.backgroundColor
                  }
                }
              };
            } else if (node.hasFeature("composer.Pipe")) {
              pipes.push({
                source : {
                  id   : node.source.parent.myId,
                  port : [node.source.direction, node.source.name]
                },
                target : {
                  id   : node.target.parent.myId,
                  port : [node.target.direction, node.target.name]
                }
              });
            }

            if (node.children && node.children.length) {
              for (var i = 0; i<node.children.length; i++) {
                recurse(node.children[i]);
              }
            }
          };
          recurse(branch);
          res.nodes = nodes;
          res.pipes = pipes;
          return res;
        };

        var saving = false;
        function save() {
          if (!saving) {
            saving = true;
            jQuery.ajax({
              type : "post",
              url  : "/nodes/",
              data : JSON.stringify(toTransport(scene)),
              contentType : "application/json",
              complete : function(data) {
                saving = false;
              }
            });
          }
        }
        var selected = null;
        jQuery.ajax({
          url : "/nodes/" + composer.currentFlow,
          dataType: "json",
          success : function(data) {
            scene = fromTransport(data);
            window.scene = scene;
            scene.width=0;
            scene.height=0;
            scene.containsPoint = function() { return true; }
          },
          error : function() {
            // Create the current flow
            jQuery.ajax({
              type : "post",
              url  : "/nodes/",
              data : { name: composer.currentFlow, type: "flow" },
              success  : function() {
                window.location.reload();
              }

            });
          },
          complete: function() {
            scene.event.bind("node.dirty", save);
            scene.event.bind("mouse.down", function(name, data) {
              selected = data.target;
            });

            // TODO: woah, this is a global handler. is this a good thing?
            scene.event.bind("mouse.click.2", function(name,data) {
              console.log("here");
              // double click
              for (var i=0; i<data.target.features.length; i++) {
                if (data.target.features[i] === "composer.Functional") {
                  jQuery.ajax({
                    url      : data.target.code,
                    dataType : "json",
                    success  : function(codeObj) {
                      spawnEditor(true, codeObj.name, codeObj.code);
                    }
                  });
                  break;
                }
              }
            });
            camera.target = scene;

            scene.dirty = true;
            setTimeout(function render() {
              var ctx = renderer.context;
              if (ctx.canvas.width !== $(window).width() ||
                  ctx.canvas.height != $(window).height()-5)
              {
                ctx.canvas.width =  $(window).width();
                ctx.canvas.height = $(window).height()-5;
              }
              camera.render();
              setTimeout(render, 1000/40);
            }, 0);
          }
        })

        var chooser = null,
            editorWindow = false;


        document.addEventListener("keydown", function(ev) {
          if (ev.keyCode === 8) { // backspace
            ev.preventDefault();
            ev.stopPropagation();

            if (selected && selected.parent) {
              var parent = selected.parent;
              selected.parent.remove(selected);
              selected = parent.child(0);
            }
          } else if (ev.keyCode === 27) { // escape
            composer.chisel.hide();

            if (editorWindow) {
              editorWindow.parent.remove(editorWindow);
              for (var i=0; i<editorWindow.children.length; i++) {
                editorWindow.children[i].parent = null;
              }
              editorWindow = false;
            }
          } else if (ev.keyCode === 32) {
            composer.chisel.show();
          } else if (ev.keyCode === 78 && ev.ctrlKey === true) {
            ev.preventDefault();
            ev.stopPropagation();
            spawnEditor(true, "", "");
          }
        }, true);


        function spawnEditor(newNode, nodeName, nodeCode) {
          // allow only one editor at a time
          if (editorWindow) {
            editorWindow.parent.remove(editorWindow);
            name.parent === null;
            editor.parent === null;
            editorWindow = false;
          }

          // spawn a new carena
          editorWindow = carena.build({
            style : {
              backgroundColor: "blue",
            },
            x:100, y: 100,
            height: 310,
            width: 400
          },[
            "carena.Node",
            "carena.Draggable"
          ]);

          var editor = carena.build({
            x:110,y:140, width: 380, height: 260
          }, [
            "carena.Node",
            "carena.RelativeToParent",
            "cider.Textual",
            "cider.Editable",
            "cider.FocusTarget"
          ]),
          lineNumbers = carena.build({},[
            "cider.LineNumbers",
            "carena.RelativeToParent"
          ]),
          name = carena.build({
            x:110,
            y:110,
            width: 270,
            height: 20
          },[
            "carena.Node",
            "carena.RelativeToParent",
            "cider.Textual",
            "cider.Editable",
            "cider.FocusTarget"
          ]),
          saveButton = carena.build({
            width: 80,
            height: 20,
            x:410,
            y:110,
            style : {
              backgroundColor: "grey"
            }
          },[
            "carena.Box",
            "carena.Eventable",
            "carena.RelativeToParent"
          ]);

          name.style.paddingLeft = 10;
          name.fromString(nodeName);
          name.setFocus();
          name.font.set(composer.defaultFont);
          editor.font.set(composer.defaultFont);
          // Setup the button
          // TODO: this probably could be made easier heh.
          saveButton.event.bind("mouse.in", function() {
            saveButton.color = "orange";
            return false;
          });
          saveButton.event.bind("mouse.out", function(name, data) {
            saveButton.color = "grey";
            return false;
          });
          saveButton.render = function(renderer) {

            renderer.context.fillStyle = saveButton.color;
            renderer.context.fillRect(saveButton.x,
                                      saveButton.y,
                                      saveButton.width,
                                      saveButton.height);

            renderer.context.fillStyle = "black";
            renderer.context.fillText("save", saveButton.x+20, saveButton.y+14);
          };
          function mouseUp(evName, data) {
            if (data.target === saveButton) {
              // Save to storage

              // remove the editor
              // TODO: figure out the root cause of this
              if (!editor.parent || !name.parent || !editorWindow.parent) {
                return;
              }
              var req = {
                contentType: "application/json",
                dataType : "json",
                data : JSON.stringify({
                  name: name.toString(),
                  code: editor.toString()
                }),
                success : function() {
                  editor.parent.remove(editor);
                  name.parent.remove(name);
                  editorWindow.parent.remove(editorWindow);
                  name.parent === null;
                  editor.parent === null;
                  editorWindow = false;
                }
              };
              jQuery.ajax({

                url: "/nodes/"+name.toString(),
                success : function() { newNode = false; },
                error   : function() { newNode = true; },
                contentType : "application/json",
                dataType : 'json',
                complete : function() {
                  req.url = (newNode) ? "/nodes" : "/nodes/" + name.toString();
                  req.type = (newNode) ? "post" : "put";
                  jQuery.ajax(req);
                }
              });

              return false;
            }
          }
          saveButton.event.bind("mouse.up", mouseUp);
          editor.fromString(nodeCode);

          camera.add(editorWindow.add(editor.add(lineNumbers)).add(name).add(saveButton));
        }

        var terminal = carena.build({
          x:0,y:renderer.canvas.height-200, width: renderer.canvas.width, height: 200,
          text: document.getElementById("terminal-text").innerText
        }, [
          "carena.Node",
          "cider.Textual",
        ]);
        terminal.font.set(composer.defaultFont);
        var _terminalRender = terminal.render;
        terminal.render = function(renderer) {
          terminal.y = renderer.canvas.height-200;
          terminal.width = renderer.canvas.width;
          _terminalRender(renderer);
        }

        camera.add(terminal);

        // Console stuff
        window.addEventListener("keydown", function(ev) {
          if (ev.keyCode === 13 && editorWindow === false) {
            terminal.fromString("> executing....");
            jQuery.get("/nodes/" + composer.currentFlow + "/run", function(data) {
              terminal.fromString(terminal + "\n> Results:\n\n" + data);
            });
          }
        });
      });
    </script>
  </head>
  <body>
      <canvas id="composer" width="600" height="600"></canvas>
<pre id="terminal-text" style="display:none">> spawning terminal...

  Add nodes to the scene and link them up to perform operations

  Keys:
    control+n - create a new node
    space     - add existing node
    escape    - close editor / menu
    click*2   - edit an existing node (menu or node)
    return    - execute (results are shown in the terminal)

</pre>
  </body>
</html>
